# Source other files

if [ -f ~/git-completion.bash ]; then
  . ~/git-completion.bash
fi

if [ -f ~/pass-completion.bash ]; then
 . ~/pass-completion.bash
fi

if [ -f ~/.bash_secret ]; then
  . ~/.bash_secret
fi

#  SETUP CONSTANTS
#  Bunch-o-predefined colours and symbols.
#  Makes reading code easier than escape sequences.

colours256() {
  local c i j

  printf "Standard 16 colours\n"
  for ((c = 0; c < 17; c++)); do
          printf "|%s%3d%s" "$(tput setaf "$c")" "$c" "$(tput sgr0)"
  done
  printf "|\n\n"

  printf "Colours 16 to 231 for 256 colours\n"
  for ((c = 16, i = j = 0; c < 232; c++, i++)); do
          printf "|"
          ((i > 5 && (i = 0, ++j))) && printf " |"
          ((j > 5 && (j = 0, 1)))   && printf "\b \n|"
          printf "%s%3d%s" "$(tput setaf "$c")" "$c" "$(tput sgr0)"
  done
  printf "|\n\n"

  printf "Greyscale 232 to 255 for 256 colours\n"
  for ((; c < 256; c++)); do
          printf "|%s%3d%s" "$(tput setaf "$c")" "$c" "$(tput sgr0)"
  done
  printf "|\n"
}

# Reset
reset=$(tput sgr0) # Resets all escape codes for colour, bold etc

# Regular Colours
black=$(tput setaf 0)
red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)
blue=$(tput setaf 4)
purple=$(tput setaf 5)
cyan=$(tput setaf 6)
white=$(tput setaf 7)
# Bright Colours
bblack=$(tput setaf 8) # Light grey
bred=$(tput setaf 9)
bgreen=$(tput setaf 10)
byellow=$(tput setaf 11)
bblue=$(tput setaf 12)
bpurple=$(tput setaf 13)
bcyan=$(tput setaf 14)
bwhite=$(tput setaf 15)

# Bold
bold=$(tput bold)
# Underline
ul=$(tput smul)
# Italic
it=$(tput sitm)
# Blink
blink=$(tput blink)
# Background
bg=$(tput smso)

tick="\342\234\223"
cross="\342\234\227"
uparr="\342\206\221"
downarr="\342\206\223"
bullet="\342\227\217"
flag="\342\232\221"

# Find out what we're running on, for path differences etc
opsys=$( uname )

previousstatus=""

function get_previous_status {
  status=$?
  if [ $status -eq 0 ]; then
    previousstatus="\[$bgreen\]$tick "
  else
    previousstatus="\[$bred$cross\]-$status "
  fi
}

gitstatus=""
gitbranch=""
gitprompt=""

# get the status of whether we're a git repository
function get_git_status {
  git status 2> /dev/null
}

# return the current branch name
function get_git_branch_name {
  git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'
}

# find the root of the current git tree
function get_git_root {
  git rev-parse --show-toplevel 2> /dev/null
}

# return the count of all added but uncommitted or modified files in the current
# repository
function get_git_staged_count {
  # basic diff gives modified files, --cached gives newly added files
  echo $((
    $( git diff --name-only | wc -l | sed -e 's/^[[:space:]]*//' ) + 
    $( git diff --cached --name-only | wc -l | sed -e 's/^[[:space:]]*//' )
  ))
}

# return the count of all untracked files in the current repository
function get_git_unstaged_count {
  git ls-files $( get_git_root ) --exclude-standard --others | wc -l | sed -e 's/^[[:space:]]*//'
}

# return the number of current entries on the stash list
function get_git_stash_count {
  git stash list | wc -l | sed -e 's/^[[:space:]]*//'
}

# set a basic prompt showing the current branch. Yellow for clean master, blue
# for any other clean branch, red for any unclean branch
function set_git_basic_prompt {
  cleancheck="^.*working (directory|tree) clean.*$"
  mergecheck="^.*All conflicts fixed but you are still merging.*$"
  if [[ "$gitstatus" =~ $cleancheck && ! "$gitstatus" =~ $mergecheck ]]; then
    if [ "$gitbranch" = "master" ]; then
      gitprompt+="\[$byellow\]"
    else
      gitprompt+="\[$bcyan\]"
    fi
  else
    gitprompt+="\[$bred\]"
  fi

  gitprompt+=$gitbranch
}

#Â set notifications for the number of commits ahead or behind master we are,
#or whether we've diverged
function set_git_origin_notification {
  aheadcheck="^.*Your branch is ahead of '.*' by ([0-9]+) commits?.*$"
  behindcheck="^.*Your branch is behind '.*' by ([0-9]+) commits?.*$"
  divergedcheck="^.*and have ([0-9]+) and ([0-9]+) different commits? each, respectively.*$"

  if [[ "$gitstatus" =~ $aheadcheck ]]; then
    gitprompt+="|$uparr${BASH_REMATCH[1]}"
  elif [[ "$gitstatus" =~ $behindcheck ]]; then
    gitprompt+="|$downarr${BASH_REMATCH[1]}"
  elif [[ "$gitstatus" =~ $divergedcheck ]]; then
    gitprompt+="|$uparr${BASH_REMATCH[1]}$downarr${BASH_REMATCH[2]}"
  fi
}

# set notifications for the number of staged but uncommitted and unstaged
# changes there are
function set_git_changes_notification {
  stagedcount=$( get_git_staged_count )
  if [ $stagedcount -gt 0 ]; then
    gitprompt+="|$bullet$stagedcount"
  fi

  unstagedcount=$( get_git_unstaged_count )
  if [ $unstagedcount -gt 0 ]; then
    gitprompt+="|+$unstagedcount"
  fi
}

# set notification for the number of commits on the stash currently
function set_git_stash_notification {
  stashcount=$( get_git_stash_count )
  if [ $stashcount -gt 0 ]; then
    gitprompt+="|$flag$stashcount"
  fi
}

# set a number of variables in the prompt based on the status of the current
# git repository
function set_git_prompt {
  gitprompt=":"
  set_git_basic_prompt
  set_git_origin_notification
  set_git_changes_notification
  set_git_stash_notification
}

PROMPT_COMMAND=prompt_command

function prompt_command {
  get_previous_status
  # are we an interactive shell?
  if [ "$PS1" ]; then
    # Root gets a #, all other users get a $
    if [ $UID == 0 ]; then
      endchar="\t #"
      promptcolour="\[$red\]"
    else
      endchar="\t \$"
      if [ -f ~/.shared ]; then
	promptcolour="\[$cyan\]"
      else
	promptcolour="\[$green\]"
      fi
    fi

    # Linux terms really don't deal with the colouration stuff very well
    if [ $TERM == "linux" ]; then
      export PS1="\u@\h \w\n$endchar "
    else
      gitstatus=$( get_git_status )
      if [ -n "$gitstatus" ]; then
	gitbranch=$( get_git_branch_name )
	# If we have a status, but no branch, we're the initial commit
	if [ -z "$gitbranch" ]; then
	  gitbranch="<init>"
	fi
	set_git_prompt
      else
	# Clear the prompt when we're not in a repository
	gitbranch=""
	gitprompt=""
      fi

      # Set the xterm title if it's usable by the terminal
      if [ $TERM == "xterm" -o $TERM == "xterm-color" -o $TERM == "xterm-256color" ]; then
        if [ -n "$gitbranch" ]; then
          title="\[\e]0;\h \w:$gitbranch\a\]"
        else
          title="\[\e]0;\h \w\a\]"
        fi
      else
        title=""
      fi

      export PS1="$title$previousstatus$promptcolour\u@\h \[$yellow\]\w$gitprompt\n\[$reset\]$endchar "
    fi
  fi
}

# Aliases Go Here
alias nslookup="nslookup -sil"

if [ $opsys == 'Linux' ]; then
  alias ls="ls -ap --color"
else
  # Assume BSD/Unix style
  alias ls="ls -apG"
fi

ssh-add &>/dev/null

alias ll="ls -l"
alias reload="source ~/.bashrc"
alias boot="boot boot.lein/generate"

export EDITOR="vim"

if [ -d "$HOME/bin" ]; then
  PATH=$PATH:$HOME/bin
fi

if [ -d "$HOME/.rbenv" ]; then
  eval "$(rbenv init -)"
fi

if [ -d "$HOME/.pyenv" ]; then
  eval "$(pyenv init -)"
fi

BASE_JAVA_OPTS=""

brew_override() {
  if [ -f ~/.curlrc ]; then
    mv ~/.curlrc ~/.curlrc.tmp
  fi

  command brew $@

  if [ -f ~/.curlrc.tmp ]; then
    mv ~/.curlrc.tmp ~/.curlrc
  fi
}

# If we're at the beeb we need proxies
if [ $opsys == 'Darwin' ]; then
  alias mlvm="~/git/mlvm/mlvm.sh"
  alias mltail="tail -f ~/Library/Application\ Support/MarkLogic/Data/Logs/ErrorLog.txt"
  alias brew=brew_override
  alias nitro="cd ${NITRO_ROOT}"
  alias pips="cd ${PIPS_ROOT}"
 
  export NITRO_ROOT="/Users/meyerd06/git/nitro/nitro-xquery/src/main/"
  export PIPS_ROOT="/Users/meyerd06/svn/pips/trunk/Pips3/"

  locationfile=/var/tmp/location
  location=$(/bin/cat ${locationfile} 2>/dev/null)

  eval $(docker-machine env docker)

  if [ "$location" == "BBC On Network" -o "$location" == "BBC On VPN" ]; then
    export http_proxy="http://www-cache.reith.bbc.co.uk:80"
    export https_proxy=$http_proxy
    export HTTP_PROXY=$http_proxy
    export HTTPS_PROXY=$http_proxy
    export no_proxy="localhost,127.0.0.1,sandbox,sandbox.bbc.co.uk,pal.sandbox.dev.bbc.co.uk"
    export NO_PROXY=$no_proxy

    export JAVA_OPTS="$BASE_JAVA_OPTS \
     -Dhttp.proxyHost=www-cache.reith.bbc.co.uk \
     -Dhttp.proxyPort=80 \
     -Dhttps.proxyHost=www-cache.reith.bbc.co.uk \
     -Dhttps.proxyPort=80 \
     -Dhttp.nonProxyHosts=localhost|national.core.bbc.co.uk|sandbox|sandbox.bbc.co.uk|*.sandbox.dev.bbc.co.uk"
  else
    unset http_proxy
    unset https_proxy
    unset no_proxy
    unset HTTP_PROXY
    unset HTTPS_PROXY
    unset NO_PROXY

    export JAVA_OPTS="$BASE_JAVA_OPTS"
  fi

  export MAVEN_OPTS="-Xms256m -Xmx512m \
    -Denv.trustStore=${HOME}/certs/jssecacerts \
    -Denv.keyStore=${HOME}/certs/meyerd06_dev.p12 \
    -Denv.keyStoreType=PKCS12 \
    -Denv.keyStorePassword=${CERT_PASSWORD}"

  export BOOT_JVM_OPTIONS="-Djavax.net.ssl.keyStore=${HOME}/certs/meyerd06_dev.p12 \
    -Djavax.net.ssl.keyStoreType=PKCS12 \
    -Djavax.net.ssl.keyStorePassword=${CERT_PASSWORD} \
    -XX:-OmitStackTraceInFastThrow"
fi
